// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.1
// source: comics.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "comics";

/**
 * Comic types enum
 * Represents different types of comics available in the system
 */
export enum ComicType {
  TYPE_UNKNOWN = 0,
  MANGA = 1,
  MANHUA = 2,
  MANHWA = 3,
  /** WEBTOON - Alias for MANHWA */
  WEBTOON = 3,
  NOVEL = 4,
  UNRECOGNIZED = -1,
}

export function comicTypeFromJSON(object: any): ComicType {
  switch (object) {
    case 0:
    case "TYPE_UNKNOWN":
      return ComicType.TYPE_UNKNOWN;
    case 1:
    case "MANGA":
      return ComicType.MANGA;
    case 2:
    case "MANHUA":
      return ComicType.MANHUA;
    case 3:
    case "MANHWA":
      return ComicType.MANHWA;
    case 3:
    case "WEBTOON":
      return ComicType.WEBTOON;
    case 4:
    case "NOVEL":
      return ComicType.NOVEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComicType.UNRECOGNIZED;
  }
}

export function comicTypeToJSON(object: ComicType): string {
  switch (object) {
    case ComicType.TYPE_UNKNOWN:
      return "TYPE_UNKNOWN";
    case ComicType.MANGA:
      return "MANGA";
    case ComicType.MANHUA:
      return "MANHUA";
    case ComicType.MANHWA:
      return "MANHWA";
    case ComicType.WEBTOON:
      return "WEBTOON";
    case ComicType.NOVEL:
      return "NOVEL";
    case ComicType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Comic status enum
 * Represents the current publication status of a comic
 */
export enum Status {
  STATUS_UNKNOWN = 0,
  COMPLETED = 1,
  ON_AIR = 2,
  BREAK = 3,
  DROPPED = 4,
  UNRECOGNIZED = -1,
}

export function statusFromJSON(object: any): Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return Status.STATUS_UNKNOWN;
    case 1:
    case "COMPLETED":
      return Status.COMPLETED;
    case 2:
    case "ON_AIR":
      return Status.ON_AIR;
    case 3:
    case "BREAK":
      return Status.BREAK;
    case 4:
    case "DROPPED":
      return Status.DROPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Status.UNRECOGNIZED;
  }
}

export function statusToJSON(object: Status): string {
  switch (object) {
    case Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case Status.COMPLETED:
      return "COMPLETED";
    case Status.ON_AIR:
      return "ON_AIR";
    case Status.BREAK:
      return "BREAK";
    case Status.DROPPED:
      return "DROPPED";
    case Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Comic genres enum
 * Represents different genres that can be assigned to a comic
 */
export enum Genre {
  GENRE_UNKNOWN = 0,
  ACTION = 1,
  ADVENTURE = 2,
  FANTASY = 3,
  OVERPOWERED = 4,
  COMEDY = 5,
  DRAMA = 6,
  SCHOOL_LIFE = 7,
  SYSTEM = 8,
  SUPERNATURAL = 9,
  MARTIAL_ARTS = 10,
  ROMANCE = 11,
  SHOUNEN = 12,
  REINCARNATION = 13,
  /** OP - Common aliases */
  OP = 4,
  /** CULTIVATION - Alias for MARTIAL_ARTS */
  CULTIVATION = 10,
  UNRECOGNIZED = -1,
}

export function genreFromJSON(object: any): Genre {
  switch (object) {
    case 0:
    case "GENRE_UNKNOWN":
      return Genre.GENRE_UNKNOWN;
    case 1:
    case "ACTION":
      return Genre.ACTION;
    case 2:
    case "ADVENTURE":
      return Genre.ADVENTURE;
    case 3:
    case "FANTASY":
      return Genre.FANTASY;
    case 4:
    case "OVERPOWERED":
      return Genre.OVERPOWERED;
    case 5:
    case "COMEDY":
      return Genre.COMEDY;
    case 6:
    case "DRAMA":
      return Genre.DRAMA;
    case 7:
    case "SCHOOL_LIFE":
      return Genre.SCHOOL_LIFE;
    case 8:
    case "SYSTEM":
      return Genre.SYSTEM;
    case 9:
    case "SUPERNATURAL":
      return Genre.SUPERNATURAL;
    case 10:
    case "MARTIAL_ARTS":
      return Genre.MARTIAL_ARTS;
    case 11:
    case "ROMANCE":
      return Genre.ROMANCE;
    case 12:
    case "SHOUNEN":
      return Genre.SHOUNEN;
    case 13:
    case "REINCARNATION":
      return Genre.REINCARNATION;
    case 4:
    case "OP":
      return Genre.OP;
    case 10:
    case "CULTIVATION":
      return Genre.CULTIVATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Genre.UNRECOGNIZED;
  }
}

export function genreToJSON(object: Genre): string {
  switch (object) {
    case Genre.GENRE_UNKNOWN:
      return "GENRE_UNKNOWN";
    case Genre.ACTION:
      return "ACTION";
    case Genre.ADVENTURE:
      return "ADVENTURE";
    case Genre.FANTASY:
      return "FANTASY";
    case Genre.OVERPOWERED:
      return "OVERPOWERED";
    case Genre.COMEDY:
      return "COMEDY";
    case Genre.DRAMA:
      return "DRAMA";
    case Genre.SCHOOL_LIFE:
      return "SCHOOL_LIFE";
    case Genre.SYSTEM:
      return "SYSTEM";
    case Genre.SUPERNATURAL:
      return "SUPERNATURAL";
    case Genre.MARTIAL_ARTS:
      return "MARTIAL_ARTS";
    case Genre.ROMANCE:
      return "ROMANCE";
    case Genre.SHOUNEN:
      return "SHOUNEN";
    case Genre.REINCARNATION:
      return "REINCARNATION";
    case Genre.OP:
      return "OP";
    case Genre.CULTIVATION:
      return "CULTIVATION";
    case Genre.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Publishers enum
 * Represents different comic publishers/scan groups
 */
export enum Publisher {
  PUBLISHER_UNKNOWN = 0,
  ASURA = 1,
  REAPER_SCANS = 2,
  MANHUA_PLUS = 3,
  FLAME_SCANS = 4,
  LUMINOUS_SCANS = 5,
  RESET_SCANS = 6,
  ISEKAI_SCAN = 7,
  REALM_SCANS = 8,
  LEVIATAN_SCANS = 9,
  NIGHT_SCANS = 10,
  VOID_SCANS = 11,
  DRAKE_SCANS = 12,
  NOVEL_MIC = 13,
  UNRECOGNIZED = -1,
}

export function publisherFromJSON(object: any): Publisher {
  switch (object) {
    case 0:
    case "PUBLISHER_UNKNOWN":
      return Publisher.PUBLISHER_UNKNOWN;
    case 1:
    case "ASURA":
      return Publisher.ASURA;
    case 2:
    case "REAPER_SCANS":
      return Publisher.REAPER_SCANS;
    case 3:
    case "MANHUA_PLUS":
      return Publisher.MANHUA_PLUS;
    case 4:
    case "FLAME_SCANS":
      return Publisher.FLAME_SCANS;
    case 5:
    case "LUMINOUS_SCANS":
      return Publisher.LUMINOUS_SCANS;
    case 6:
    case "RESET_SCANS":
      return Publisher.RESET_SCANS;
    case 7:
    case "ISEKAI_SCAN":
      return Publisher.ISEKAI_SCAN;
    case 8:
    case "REALM_SCANS":
      return Publisher.REALM_SCANS;
    case 9:
    case "LEVIATAN_SCANS":
      return Publisher.LEVIATAN_SCANS;
    case 10:
    case "NIGHT_SCANS":
      return Publisher.NIGHT_SCANS;
    case 11:
    case "VOID_SCANS":
      return Publisher.VOID_SCANS;
    case 12:
    case "DRAKE_SCANS":
      return Publisher.DRAKE_SCANS;
    case 13:
    case "NOVEL_MIC":
      return Publisher.NOVEL_MIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Publisher.UNRECOGNIZED;
  }
}

export function publisherToJSON(object: Publisher): string {
  switch (object) {
    case Publisher.PUBLISHER_UNKNOWN:
      return "PUBLISHER_UNKNOWN";
    case Publisher.ASURA:
      return "ASURA";
    case Publisher.REAPER_SCANS:
      return "REAPER_SCANS";
    case Publisher.MANHUA_PLUS:
      return "MANHUA_PLUS";
    case Publisher.FLAME_SCANS:
      return "FLAME_SCANS";
    case Publisher.LUMINOUS_SCANS:
      return "LUMINOUS_SCANS";
    case Publisher.RESET_SCANS:
      return "RESET_SCANS";
    case Publisher.ISEKAI_SCAN:
      return "ISEKAI_SCAN";
    case Publisher.REALM_SCANS:
      return "REALM_SCANS";
    case Publisher.LEVIATAN_SCANS:
      return "LEVIATAN_SCANS";
    case Publisher.NIGHT_SCANS:
      return "NIGHT_SCANS";
    case Publisher.VOID_SCANS:
      return "VOID_SCANS";
    case Publisher.DRAKE_SCANS:
      return "DRAKE_SCANS";
    case Publisher.NOVEL_MIC:
      return "NOVEL_MIC";
    case Publisher.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Rating enum
 * Represents user ratings for comics
 */
export enum Rating {
  RATING_UNKNOWN = 0,
  F_RATED = 1,
  E_RATED = 2,
  D_RATED = 3,
  C_RATED = 4,
  B_RATED = 5,
  A_RATED = 6,
  S_RATED = 7,
  SS_RATED = 8,
  SSS_RATED = 9,
  /** F - Common aliases */
  F = 1,
  /** ONE_STAR - Alias for F_RATED */
  ONE_STAR = 1,
  /** E - Alias for E_RATED */
  E = 2,
  /** D - Alias for D_RATED */
  D = 3,
  /** TWO_STARS - Alias for D_RATED */
  TWO_STARS = 3,
  /** C - Alias for C_RATED */
  C = 4,
  /** B - Alias for B_RATED */
  B = 5,
  /** THREE_STARS - Alias for B_RATED */
  THREE_STARS = 5,
  /** A - Alias for A_RATED */
  A = 6,
  /** S - Alias for S_RATED */
  S = 7,
  /** FOUR_STARS - Alias for S_RATED */
  FOUR_STARS = 7,
  /** SS - Alias for SS_RATED */
  SS = 8,
  /** SSS - Alias for SSS_RATED */
  SSS = 9,
  /** FIVE_STARS - Alias for SSS_RATED */
  FIVE_STARS = 9,
  UNRECOGNIZED = -1,
}

export function ratingFromJSON(object: any): Rating {
  switch (object) {
    case 0:
    case "RATING_UNKNOWN":
      return Rating.RATING_UNKNOWN;
    case 1:
    case "F_RATED":
      return Rating.F_RATED;
    case 2:
    case "E_RATED":
      return Rating.E_RATED;
    case 3:
    case "D_RATED":
      return Rating.D_RATED;
    case 4:
    case "C_RATED":
      return Rating.C_RATED;
    case 5:
    case "B_RATED":
      return Rating.B_RATED;
    case 6:
    case "A_RATED":
      return Rating.A_RATED;
    case 7:
    case "S_RATED":
      return Rating.S_RATED;
    case 8:
    case "SS_RATED":
      return Rating.SS_RATED;
    case 9:
    case "SSS_RATED":
      return Rating.SSS_RATED;
    case 1:
    case "F":
      return Rating.F;
    case 1:
    case "ONE_STAR":
      return Rating.ONE_STAR;
    case 2:
    case "E":
      return Rating.E;
    case 3:
    case "D":
      return Rating.D;
    case 3:
    case "TWO_STARS":
      return Rating.TWO_STARS;
    case 4:
    case "C":
      return Rating.C;
    case 5:
    case "B":
      return Rating.B;
    case 5:
    case "THREE_STARS":
      return Rating.THREE_STARS;
    case 6:
    case "A":
      return Rating.A;
    case 7:
    case "S":
      return Rating.S;
    case 7:
    case "FOUR_STARS":
      return Rating.FOUR_STARS;
    case 8:
    case "SS":
      return Rating.SS;
    case 9:
    case "SSS":
      return Rating.SSS;
    case 9:
    case "FIVE_STARS":
      return Rating.FIVE_STARS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Rating.UNRECOGNIZED;
  }
}

export function ratingToJSON(object: Rating): string {
  switch (object) {
    case Rating.RATING_UNKNOWN:
      return "RATING_UNKNOWN";
    case Rating.F_RATED:
      return "F_RATED";
    case Rating.E_RATED:
      return "E_RATED";
    case Rating.D_RATED:
      return "D_RATED";
    case Rating.C_RATED:
      return "C_RATED";
    case Rating.B_RATED:
      return "B_RATED";
    case Rating.A_RATED:
      return "A_RATED";
    case Rating.S_RATED:
      return "S_RATED";
    case Rating.SS_RATED:
      return "SS_RATED";
    case Rating.SSS_RATED:
      return "SSS_RATED";
    case Rating.F:
      return "F";
    case Rating.ONE_STAR:
      return "ONE_STAR";
    case Rating.E:
      return "E";
    case Rating.D:
      return "D";
    case Rating.TWO_STARS:
      return "TWO_STARS";
    case Rating.C:
      return "C";
    case Rating.B:
      return "B";
    case Rating.THREE_STARS:
      return "THREE_STARS";
    case Rating.A:
      return "A";
    case Rating.S:
      return "S";
    case Rating.FOUR_STARS:
      return "FOUR_STARS";
    case Rating.SS:
      return "SS";
    case Rating.SSS:
      return "SSS";
    case Rating.FIVE_STARS:
      return "FIVE_STARS";
    case Rating.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Comics collection message */
export interface Comics {
  comics: Comic[];
}

/**
 * Comic message definition
 * Represents a comic book with all its metadata and user interaction
 * information
 */
export interface Comic {
  /** Primary identifiers */
  id: number;
  /** At least one title required */
  titles: string[];
  /** Basic information */
  author: string;
  description: string;
  com_type: ComicType;
  status: Status;
  /** Content metadata */
  cover: string;
  current_chap: number;
  /** Using standard timestamp */
  last_update:
    | Date
    | undefined;
  /** Classifications */
  published_in: Publisher[];
  genres: Genre[];
  rating: Rating;
  /** User interaction fields */
  track: boolean;
  viewed_chap: number;
  deleted: boolean;
}

function createBaseComics(): Comics {
  return { comics: [] };
}

export const Comics: MessageFns<Comics> = {
  encode(message: Comics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.comics) {
      Comic.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Comics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.comics.push(Comic.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Comics {
    return { comics: globalThis.Array.isArray(object?.comics) ? object.comics.map((e: any) => Comic.fromJSON(e)) : [] };
  },

  toJSON(message: Comics): unknown {
    const obj: any = {};
    if (message.comics?.length) {
      obj.comics = message.comics.map((e) => Comic.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Comics>, I>>(base?: I): Comics {
    return Comics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Comics>, I>>(object: I): Comics {
    const message = createBaseComics();
    message.comics = object.comics?.map((e) => Comic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseComic(): Comic {
  return {
    id: 0,
    titles: [],
    author: "",
    description: "",
    com_type: 0,
    status: 0,
    cover: "",
    current_chap: 0,
    last_update: undefined,
    published_in: [],
    genres: [],
    rating: 0,
    track: false,
    viewed_chap: 0,
    deleted: false,
  };
}

export const Comic: MessageFns<Comic> = {
  encode(message: Comic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    for (const v of message.titles) {
      writer.uint32(18).string(v!);
    }
    if (message.author !== "") {
      writer.uint32(26).string(message.author);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.com_type !== 0) {
      writer.uint32(40).int32(message.com_type);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.cover !== "") {
      writer.uint32(58).string(message.cover);
    }
    if (message.current_chap !== 0) {
      writer.uint32(64).uint32(message.current_chap);
    }
    if (message.last_update !== undefined) {
      Timestamp.encode(toTimestamp(message.last_update), writer.uint32(74).fork()).join();
    }
    writer.uint32(82).fork();
    for (const v of message.published_in) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(90).fork();
    for (const v of message.genres) {
      writer.int32(v);
    }
    writer.join();
    if (message.rating !== 0) {
      writer.uint32(96).int32(message.rating);
    }
    if (message.track !== false) {
      writer.uint32(104).bool(message.track);
    }
    if (message.viewed_chap !== 0) {
      writer.uint32(112).uint32(message.viewed_chap);
    }
    if (message.deleted !== false) {
      writer.uint32(120).bool(message.deleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Comic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.titles.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.author = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.com_type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cover = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.current_chap = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.last_update = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag === 80) {
            message.published_in.push(reader.int32() as any);

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.published_in.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 11: {
          if (tag === 88) {
            message.genres.push(reader.int32() as any);

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.genres.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.rating = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.track = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.viewed_chap = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.deleted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Comic {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      titles: globalThis.Array.isArray(object?.titles) ? object.titles.map((e: any) => globalThis.String(e)) : [],
      author: isSet(object.author) ? globalThis.String(object.author) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      com_type: isSet(object.com_type) ? comicTypeFromJSON(object.com_type) : 0,
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      cover: isSet(object.cover) ? globalThis.String(object.cover) : "",
      current_chap: isSet(object.current_chap) ? globalThis.Number(object.current_chap) : 0,
      last_update: isSet(object.last_update) ? fromJsonTimestamp(object.last_update) : undefined,
      published_in: globalThis.Array.isArray(object?.published_in)
        ? object.published_in.map((e: any) => publisherFromJSON(e))
        : [],
      genres: globalThis.Array.isArray(object?.genres) ? object.genres.map((e: any) => genreFromJSON(e)) : [],
      rating: isSet(object.rating) ? ratingFromJSON(object.rating) : 0,
      track: isSet(object.track) ? globalThis.Boolean(object.track) : false,
      viewed_chap: isSet(object.viewed_chap) ? globalThis.Number(object.viewed_chap) : 0,
      deleted: isSet(object.deleted) ? globalThis.Boolean(object.deleted) : false,
    };
  },

  toJSON(message: Comic): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.titles?.length) {
      obj.titles = message.titles;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.com_type !== 0) {
      obj.com_type = comicTypeToJSON(message.com_type);
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.cover !== "") {
      obj.cover = message.cover;
    }
    if (message.current_chap !== 0) {
      obj.current_chap = Math.round(message.current_chap);
    }
    if (message.last_update !== undefined) {
      obj.last_update = message.last_update.toISOString();
    }
    if (message.published_in?.length) {
      obj.published_in = message.published_in.map((e) => publisherToJSON(e));
    }
    if (message.genres?.length) {
      obj.genres = message.genres.map((e) => genreToJSON(e));
    }
    if (message.rating !== 0) {
      obj.rating = ratingToJSON(message.rating);
    }
    if (message.track !== false) {
      obj.track = message.track;
    }
    if (message.viewed_chap !== 0) {
      obj.viewed_chap = Math.round(message.viewed_chap);
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Comic>, I>>(base?: I): Comic {
    return Comic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Comic>, I>>(object: I): Comic {
    const message = createBaseComic();
    message.id = object.id ?? 0;
    message.titles = object.titles?.map((e) => e) || [];
    message.author = object.author ?? "";
    message.description = object.description ?? "";
    message.com_type = object.com_type ?? 0;
    message.status = object.status ?? 0;
    message.cover = object.cover ?? "";
    message.current_chap = object.current_chap ?? 0;
    message.last_update = object.last_update ?? undefined;
    message.published_in = object.published_in?.map((e) => e) || [];
    message.genres = object.genres?.map((e) => e) || [];
    message.rating = object.rating ?? 0;
    message.track = object.track ?? false;
    message.viewed_chap = object.viewed_chap ?? 0;
    message.deleted = object.deleted ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
